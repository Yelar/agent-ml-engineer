Integration Guide v1
====================

Last updated: 2025-02-14

Overview
--------
The frontend is a minimal notebook-style interface with three pieces that rely on backend integrations:
- `UploadBar` asks the backend to ingest a CSV and returns a `session_id`.
- `ChatSidebar` sends chat prompts and expects streamed answers tied to the current session.
- `NotebookView` subscribes to notebook events over WebSocket and renders them as they arrive.

All interactions are keyed by `session_id`. The frontend keeps this value in `App.tsx` and passes it to the chat and notebook views.

File references
---------------
- Frontend entry point: `frontend/src/App.tsx`
- Upload actions: `frontend/src/components/UploadBar.tsx`
- Chat interface: `frontend/src/components/ChatSidebar.tsx`
- Notebook event hook: `frontend/src/hooks/useSessionEvents.ts`

Upload endpoint
---------------
1. URL: `POST http://localhost:8000/upload`
2. Request body: `multipart/form-data` with a single field named `csv` containing the uploaded file.
3. Expected response:
   ```json
   {
     "session_id": "string"
   }
   ```
4. The returned `session_id` becomes the source of truth for the rest of the session. When integrating, restore the commented upload logic inside `UploadBar.tsx` (currently stubbed for local testing).

Notebook event stream
---------------------
1. WebSocket URL pattern: `ws://localhost:8000/sessions/{session_id}/events`
2. Each message should be a JSON object matching the `EventMsg` interface:
   ```json
   {
     "event_id": "uuid-or-unique-string",
     "type": "string",          // e.g., "log", "plot", "table"
     "step": "optional-string", // rendered if present
     "payload": {} | [] | ""    // arbitrary JSON; strings are displayed as-is
   }
   ```
3. The frontend appends events in the order received and auto-scrolls the notebook view.
4. For smooth animations, ensure each `event_id` is uniqueâ€”duplication will replace the existing entry.

Chat endpoint
-------------
1. URL: `POST http://localhost:8000/chat`
2. Request body:
   ```json
   {
     "message": "user prompt",
     "session_id": "the current session id"
   }
   ```
3. Expected response:
   ```json
   {
     "reply": "assistant response"
   }
   ```
4. Errors should return a 4xx/5xx status; the frontend displays a fallback message when the request fails.

Session lifecycle
-----------------
- Uploading a new CSV replaces the `session_id`, clears the chat transcript, and starts listening to a fresh WebSocket channel.
- If a session does not exist or has expired, return an HTTP error; the frontend will block sending messages until a valid `session_id` exists.

Local testing tips
------------------
- Use `npm run dev` inside `frontend/` to run the UI during backend development.
- You can simulate notebook events by connecting to the WebSocket manually and sending JSON messages with unique `event_id`s.
- When the backend is not available, the current `UploadBar` stub can be used to inject a dummy session id (see `handleUpload` in the component).

Future improvements
-------------------
- Reinstate the real upload request once the backend endpoint is stable.
- Consider adding server-sent heartbeats on the event stream so the client can surface connection issues.

Contact
-------
Questions or updates to this guide: coordinate with the frontend team and update this document as the contract evolves.
