Integration Guide v1
====================

Last updated: 2025-02-14

Overview
--------
The frontend now boots into a single-pane “composer” (similar to ChatGPT/Lovable). Users can attach datasets and send the very first prompt from this screen. As soon as the first prompt is submitted, the layout morphs into the two-column notebook experience.

Key integration points:
- Dataset ingestion is invoked from both the pre-session composer (attachment icon) and the notebook upload bar.
- Chat prompts are dispatched by the global send handler and expect backend replies keyed by `session_id`.
- Notebook updates stream in over WebSocket and are rendered in near-real time.
- For backend-free demos, the composer exposes a “Try demo data” shortcut that spins up a temporary session and drives the simulated notebook output.

All interactions are keyed by `session_id`. The frontend keeps this value in `App.tsx` and passes it to the chat and notebook views.

File references
---------------
- Frontend entry point: `frontend/src/App.tsx`
- Pre-session composer: `frontend/src/components/PreSessionView.tsx`
- Upload controls (active notebook): `frontend/src/components/UploadBar.tsx`
- Chat sidebar (active session): `frontend/src/components/ChatSidebar.tsx`
- Notebook event hook: `frontend/src/hooks/useSessionEvents.ts`

Upload endpoint
---------------
1. URL: `POST http://localhost:8000/upload`
2. Request body: `multipart/form-data` with a field named `csv` for each uploaded file (the UI supports multiple files in one selection).
3. Expected response:
   ```json
   {
     "session_id": "string"
   }
   ```
4. The returned `session_id` is stored globally and shared with the chat and notebook views. Re-uploading (single or multiple files) is treated as a fresh session.

Notebook event stream
---------------------
1. WebSocket URL pattern: `ws://localhost:8000/sessions/{session_id}/events`
2. Each message should be a JSON object matching the `EventMsg` interface:
   ```json
   {
     "event_id": "uuid-or-unique-string",
     "type": "string",          // e.g., "log", "plot", "table"
     "step": "optional-string", // rendered if present
     "payload": {} | [] | ""    // arbitrary JSON; strings are displayed as-is
   }
   ```
3. The frontend appends events in the order received and auto-scrolls the notebook view.
4. For smooth animations, ensure each `event_id` is unique—duplication will replace the existing entry.

Chat endpoint
-------------
1. URL: `POST http://localhost:8000/chat`
2. Request body:
   ```json
   {
     "message": "user prompt",
     "session_id": "the current session id"
   }
   ```
3. Expected response:
   ```json
   {
     "reply": "assistant response"
   }
   ```
4. Errors should return a 4xx/5xx status; the frontend displays a fallback message when the request fails.

Session lifecycle
-----------------
- Uploading one or more CSVs replaces the `session_id`, clears previous chat history, and resets the notebook view.
- The notebook panel is hidden until the user sends the first prompt; once a prompt succeeds, notebook events are appended in real time.
- If a session does not exist or has expired, return an HTTP error; the frontend shows a friendly fallback message and keeps the composer disabled until a dataset is uploaded again.

Local testing tips
------------------
- Use `npm run dev` inside `frontend/` to run the UI during backend development.
- The frontend currently simulates notebook events after each prompt; once the WebSocket backend is ready, disable the simulation by sending real events.
- Manual testing of the upload endpoint is easiest via the attachment icon (pre-session) or the upload bar (active notebook). Both paths call the same API.
- To preview the full flow without a backend, click “Try demo data” in the composer, then send a prompt—the chat reply and notebook cells will use the built-in simulation.

Future improvements
-------------------
- Wire the chat and notebook flows to production endpoints (remove the simulated event generator once sockets are live).
- Consider adding server-sent heartbeats on the event stream so the client can surface connection issues.

Contact
-------
Questions or updates to this guide: coordinate with the frontend team and update this document as the contract evolves.
