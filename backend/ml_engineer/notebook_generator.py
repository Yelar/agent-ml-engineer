"""
Jupyter notebook generator from execution history
"""

import json
from pathlib import Path
from typing import List, Dict, Any
from datetime import datetime


class NotebookGenerator:
    """Generate Jupyter notebooks from execution history"""

    def __init__(self):
        self.cells = []

    def add_markdown_cell(self, content: str):
        """Add a markdown cell to the notebook"""
        # Split by lines and preserve newlines for all but the last line
        lines = content.split('\n')
        source = [line + '\n' for line in lines[:-1]]
        if lines[-1]:  # Add last line without newline if it's not empty
            source.append(lines[-1])

        self.cells.append({
            "cell_type": "markdown",
            "metadata": {},
            "source": source
        })

    def add_code_cell(self, code: str, outputs: List[Dict] = None):
        """Add a code cell to the notebook"""
        # Split by lines and preserve newlines for all but the last line
        lines = code.split('\n')
        source = [line + '\n' for line in lines[:-1]]
        if lines[-1]:  # Add last line without newline if it's not empty
            source.append(lines[-1])

        cell = {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "source": source,
            "outputs": outputs or []
        }
        self.cells.append(cell)

    def create_output(self, text: str = None, image_base64: str = None) -> Dict:
        """Create an output object for a code cell"""
        if image_base64:
            return {
                "output_type": "display_data",
                "data": {
                    "image/png": image_base64
                },
                "metadata": {}
            }
        elif text:
            # Split text into lines with newlines preserved
            lines = text.split('\n')
            text_lines = [line + '\n' for line in lines[:-1]]
            if lines[-1]:
                text_lines.append(lines[-1])

            return {
                "output_type": "stream",
                "name": "stdout",
                "text": text_lines
            }
        return {}

    def generate_from_execution_history(
        self,
        execution_history: List[Dict[str, Any]],
        dataset_name: str,
        user_prompt: str,
        solution: str = None
    ) -> dict:
        """
        Generate a Jupyter notebook from execution history

        This is a deterministic generator that simply converts each executed code chunk
        into a separate notebook cell, preserving the exact order of execution.

        Args:
            execution_history: List of execution results
            dataset_name: Name of the dataset
            user_prompt: Original user prompt
            solution: Final solution text

        Returns:
            Jupyter notebook as a dictionary
        """
        # Clear cells
        self.cells = []

        # Add title and introduction
        self.add_markdown_cell(f"""# ML Pipeline: {dataset_name}

**Generated by ML Engineer Agent**
**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Task
{user_prompt}
""")

        # Process execution history - convert each code chunk to a cell
        for i, execution in enumerate(execution_history, 1):
            # Only include successful executions
            if not execution.get('success', False):
                continue

            code = execution.get('code', '').strip()
            if not code:
                continue

            # Create outputs list for this cell
            outputs = []

            # Add text output if available
            if execution.get('output'):
                outputs.append(self.create_output(text=execution['output']))

            # Add plots if available
            for plot_base64 in execution.get('plots', []):
                outputs.append(self.create_output(image_base64=plot_base64))

            # Add the code cell with outputs
            self.add_code_cell(code, outputs)

        # Add solution/summary if available
        if solution:
            self.add_markdown_cell(f"""---

## Summary

{solution}
""")

        # Create notebook structure
        notebook = {
            "cells": self.cells,
            "metadata": {
                "kernelspec": {
                    "display_name": "Python 3",
                    "language": "python",
                    "name": "python3"
                },
                "language_info": {
                    "codemirror_mode": {
                        "name": "ipython",
                        "version": 3
                    },
                    "file_extension": ".py",
                    "mimetype": "text/x-python",
                    "name": "python",
                    "nbconvert_exporter": "python",
                    "pygments_lexer": "ipython3",
                    "version": "3.9.0"
                }
            },
            "nbformat": 4,
            "nbformat_minor": 5
        }

        return notebook

    def save(self, notebook: dict, output_path: str):
        """Save the notebook to a file"""
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(notebook, f, indent=2, ensure_ascii=False)


def generate_notebook(
    execution_history: List[Dict[str, Any]],
    dataset_name: str,
    user_prompt: str,
    output_path: str,
    solution: str = None
) -> str:
    """
    Convenience function to generate and save a notebook

    Args:
        execution_history: List of execution results
        dataset_name: Name of the dataset
        user_prompt: Original user prompt
        output_path: Path to save the notebook
        solution: Final solution text

    Returns:
        Path to the saved notebook
    """
    generator = NotebookGenerator()
    notebook = generator.generate_from_execution_history(
        execution_history=execution_history,
        dataset_name=dataset_name,
        user_prompt=user_prompt,
        solution=solution
    )

    # Ensure output directory exists
    Path(output_path).parent.mkdir(parents=True, exist_ok=True)

    generator.save(notebook, output_path)
    return output_path